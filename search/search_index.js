const local_index = {"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Compax Navigation App Documentation Introduction Project Overview: The Classroom Finder web app is a platform that allows users to search for available classrooms and make reservations in educational institutions. Purpose of the Document: This document serves as a comprehensive guide for the development, deployment, and maintenance of the Classroom Finder app. The structure of flow is highlighted below. You can directly use the content as a step by step tutorial on how we built this product, how we would maintain, and the principles behind the workflow. Architecture and System Design Technology Stack Used Security Measures and Authentication Development Environment Setup Database Design and Schema APIs and Endpoints Error Handling and Logging Testing Approaches and Test Cases Deployment Instructions","title":"Welcome to Compax Navigation App Documentation"},{"location":"#welcome-to-compax-navigation-app-documentation","text":"","title":"Welcome to Compax Navigation App Documentation"},{"location":"#introduction","text":"Project Overview: The Classroom Finder web app is a platform that allows users to search for available classrooms and make reservations in educational institutions. Purpose of the Document: This document serves as a comprehensive guide for the development, deployment, and maintenance of the Classroom Finder app. The structure of flow is highlighted below. You can directly use the content as a step by step tutorial on how we built this product, how we would maintain, and the principles behind the workflow.","title":"Introduction"},{"location":"#architecture-and-system-design","text":"Technology Stack Used Security Measures and Authentication","title":"Architecture and System Design"},{"location":"#development-environment-setup","text":"Database Design and Schema APIs and Endpoints Error Handling and Logging Testing Approaches and Test Cases Deployment Instructions","title":"Development Environment Setup"},{"location":"002_architecture/","text":"Architecture and System Design The backend architecture of the Compax web app follows a layered and modular approach to ensure maintainability, scalability, and separation of concerns. Layers Presentation Layer: Handles the incoming HTTP requests and outgoing HTTP responses. It interacts with the frontend and exposes the API endpoints. Business Layer: Contains the business logic of the application, including handling user authentication, classroom search, booking management, and user profile management. Data Access Layer: Responsible for interacting with the database. It includes functions to perform CRUD operations and retrieve data using an ORM library such as SQLAlchemy. Database Layer: Represents the chosen database system (e.g., SQLite or PostgreSQL) and stores the application's data. System Components API Router: Receives the incoming requests and directs them to the appropriate API handler functions based on the requested endpoint. API Handlers: Implements the logic for each API endpoint. It validates incoming requests, performs necessary actions, and returns appropriate responses. Authentication Middleware: Intercepts and validates requests to ensure the user is authenticated and authorized to access protected endpoints. Data Models: Defines the object-relational mapping for the entities (e.g., User, Classroom, Booking) using an ORM library. It represents the database tables and relationships.","title":"Architecture and System Design"},{"location":"002_architecture/#architecture-and-system-design","text":"The backend architecture of the Compax web app follows a layered and modular approach to ensure maintainability, scalability, and separation of concerns.","title":"Architecture and System Design"},{"location":"002_architecture/#layers","text":"Presentation Layer: Handles the incoming HTTP requests and outgoing HTTP responses. It interacts with the frontend and exposes the API endpoints. Business Layer: Contains the business logic of the application, including handling user authentication, classroom search, booking management, and user profile management. Data Access Layer: Responsible for interacting with the database. It includes functions to perform CRUD operations and retrieve data using an ORM library such as SQLAlchemy. Database Layer: Represents the chosen database system (e.g., SQLite or PostgreSQL) and stores the application's data.","title":"Layers"},{"location":"002_architecture/#system-components","text":"API Router: Receives the incoming requests and directs them to the appropriate API handler functions based on the requested endpoint. API Handlers: Implements the logic for each API endpoint. It validates incoming requests, performs necessary actions, and returns appropriate responses. Authentication Middleware: Intercepts and validates requests to ensure the user is authenticated and authorized to access protected endpoints. Data Models: Defines the object-relational mapping for the entities (e.g., User, Classroom, Booking) using an ORM library. It represents the database tables and relationships.","title":"System Components"},{"location":"003_technology_stack_used._for_backend/","text":"Technology Stack The technology stack used in the backend of the Compax web app is chosen to provide a robust, scalable, and high-performance foundation for handling API requests, managing data, and ensuring security. Here's an elaborate explanation of the technology stack components: Programming Language Python Python is the programming language chosen for the backend development. It is known for its simplicity, readability, and versatility, making it a popular choice for web development tasks. FastAPI , being a Python-based framework, allows developers to leverage Python's extensive ecosystem of libraries and packages for additional functionalities. Backend Server FastAPI FastAPI is the primary backend web framework used for building APIs with Python. It offers high performance, thanks to its asynchronous capabilities, making it suitable for handling a large number of concurrent requests. FastAPI is designed to be easy to use and developer-friendly, enabling rapid development with automatic validation and interactive API documentation generation. Uvicorn Uvicorn is an ASGI (Asynchronous Server Gateway Interface) server implementation used to run the FastAPI application. Uvicorn provides high-performance asynchronous handling of requests, making it an excellent choice for FastAPI applications. Databases PostgreSQL PostgreSQL is the database management system used to store and manage data for the Compax web app. It is an open-source, powerful, and scalable relational database. PostgreSQL offers features like JSONB data type, which allows storing semi-structured data, making it suitable for scenarios where flexibility in data storage is needed. Supabase Supabase Supabase is our primary soure for database also providing real-time capabilities and authentication services. It can be used for features like real-time updates or user authentication, depending on the project requirements. CI/CD and Version Control Docker Docker is used for containerizing the backend application, ensuring consistency and portability across different environments. Containerization with Docker allows for easy deployment and scaling, making it a popular choice for modern web application development. Git Git is used for version control, enabling collaborative development, and keeping track of changes in the source code. The chosen technology stack ensures that the backend of the Compax web app is efficient, secure, and well-structured. It leverages the power of FastAPI and Python for handling API requests, PostgreSQL for data management, and JWT for secure authentication. Additionally, the use of Docker enables seamless deployment and scaling, while Git allows for version control and easy collaboration among developers.","title":"Technology Stack"},{"location":"003_technology_stack_used._for_backend/#technology-stack","text":"The technology stack used in the backend of the Compax web app is chosen to provide a robust, scalable, and high-performance foundation for handling API requests, managing data, and ensuring security. Here's an elaborate explanation of the technology stack components:","title":"Technology Stack"},{"location":"003_technology_stack_used._for_backend/#programming-language","text":"","title":"Programming Language"},{"location":"003_technology_stack_used._for_backend/#python","text":"Python is the programming language chosen for the backend development. It is known for its simplicity, readability, and versatility, making it a popular choice for web development tasks. FastAPI , being a Python-based framework, allows developers to leverage Python's extensive ecosystem of libraries and packages for additional functionalities.","title":"Python   "},{"location":"003_technology_stack_used._for_backend/#backend-server","text":"","title":"Backend Server"},{"location":"003_technology_stack_used._for_backend/#fastapi","text":"FastAPI is the primary backend web framework used for building APIs with Python. It offers high performance, thanks to its asynchronous capabilities, making it suitable for handling a large number of concurrent requests. FastAPI is designed to be easy to use and developer-friendly, enabling rapid development with automatic validation and interactive API documentation generation.","title":"FastAPI "},{"location":"003_technology_stack_used._for_backend/#uvicorn","text":"Uvicorn is an ASGI (Asynchronous Server Gateway Interface) server implementation used to run the FastAPI application. Uvicorn provides high-performance asynchronous handling of requests, making it an excellent choice for FastAPI applications.","title":"Uvicorn "},{"location":"003_technology_stack_used._for_backend/#databases","text":"","title":"Databases"},{"location":"003_technology_stack_used._for_backend/#postgresql","text":"PostgreSQL is the database management system used to store and manage data for the Compax web app. It is an open-source, powerful, and scalable relational database. PostgreSQL offers features like JSONB data type, which allows storing semi-structured data, making it suitable for scenarios where flexibility in data storage is needed.","title":"PostgreSQL   "},{"location":"003_technology_stack_used._for_backend/#supabase-supabase","text":"Supabase is our primary soure for database also providing real-time capabilities and authentication services. It can be used for features like real-time updates or user authentication, depending on the project requirements.","title":"Supabase Supabase"},{"location":"003_technology_stack_used._for_backend/#cicd-and-version-control","text":"","title":"CI/CD and Version Control"},{"location":"003_technology_stack_used._for_backend/#docker","text":"Docker is used for containerizing the backend application, ensuring consistency and portability across different environments. Containerization with Docker allows for easy deployment and scaling, making it a popular choice for modern web application development.","title":"Docker   "},{"location":"003_technology_stack_used._for_backend/#git","text":"Git is used for version control, enabling collaborative development, and keeping track of changes in the source code. The chosen technology stack ensures that the backend of the Compax web app is efficient, secure, and well-structured. It leverages the power of FastAPI and Python for handling API requests, PostgreSQL for data management, and JWT for secure authentication. Additionally, the use of Docker enables seamless deployment and scaling, while Git allows for version control and easy collaboration among developers.","title":"Git   "},{"location":"004_api_endpoints/","text":"API Design Principles When designing APIs for the Compax web app, it's important to follow these best practices to ensure consistency, ease of use, and scalability: RESTful Design: Design the APIs following the principles of Representational State Transfer (REST). Use resource-based URLs and appropriate HTTP methods (GET, POST, PUT, DELETE) for operations. Endpoint Naming: Use descriptive and meaningful names for endpoints that reflect the action being performed. Request and Response Formats: Define consistent request and response formats, such as JSON, to ensure compatibility and ease of integration with the frontend. Versioning: Consider versioning the APIs to maintain backward compatibility and allow for future enhancements. Authentication and Authorization: Implement appropriate authentication and authorization mechanisms, such as token-based authentication (e.g., JWT), to secure access to protected endpoints.","title":"API Design Principles"},{"location":"004_api_endpoints/#api-design-principles","text":"When designing APIs for the Compax web app, it's important to follow these best practices to ensure consistency, ease of use, and scalability: RESTful Design: Design the APIs following the principles of Representational State Transfer (REST). Use resource-based URLs and appropriate HTTP methods (GET, POST, PUT, DELETE) for operations. Endpoint Naming: Use descriptive and meaningful names for endpoints that reflect the action being performed. Request and Response Formats: Define consistent request and response formats, such as JSON, to ensure compatibility and ease of integration with the frontend. Versioning: Consider versioning the APIs to maintain backward compatibility and allow for future enhancements. Authentication and Authorization: Implement appropriate authentication and authorization mechanisms, such as token-based authentication (e.g., JWT), to secure access to protected endpoints.","title":"API Design Principles"},{"location":"005_security_measures_and_authentication/","text":"Security Security is a critical aspect of any web application, and the Compax web app must implement robust measures to protect user data, prevent unauthorized access, and ensure secure communication between the frontend and backend. Here's an elaboration on the security measures and authentication methods used in the Compax web app: Secure Communication (HTTPS) : All communication between the frontend and backend of the Compax web app should be encrypted using HTTPS (HTTP Secure). HTTPS ensures that data transmitted between the client and server is encrypted, preventing eavesdropping and man-in-the-middle attacks. Authentication with JSON Web Tokens (JWT) : JSON Web Tokens (JWT) are used for user authentication in the Compax web app. When a user successfully logs in, the backend generates a JWT containing user information and a signature. This token is then sent back to the client and included in subsequent requests as an Authorization header. The server verifies the JWT's authenticity and extracts user information from it to grant access to protected endpoints. JWTs are stateless, meaning the server does not need to store session data, reducing server-side overhead. Hashing and Salting Passwords : User passwords should never be stored in plaintext. Instead, they are hashed and salted before being stored in the database. Hashing transforms the password into an irreversible string, while salting adds additional randomness to the hashing process, making it more secure against brute-force attacks. User Roles and Permissions : Different user roles (regular users, administrators, exam officers) have varying levels of access to the application's functionalities. Role-based access control (RBAC) is implemented to ensure that users can only access features relevant to their roles. Rate Limiting : Rate limiting is implemented to prevent brute-force attacks and excessive API requests from a single client. By imposing limits on the number of requests a client can make within a specific time frame, the backend mitigates potential abuse. Input Validation and Sanitization : Input validation is crucial to prevent security vulnerabilities like SQL injection and cross-site scripting (XSS). All user inputs should be validated and sanitized before processing to avoid malicious code execution. Error Handling and Logging : Comprehensive error handling is implemented to provide users with appropriate error messages while avoiding exposing sensitive information. Logs are generated to monitor application behavior and identify potential security issues. - Session Management (Optional) : While the Compax web app primarily uses stateless JWT authentication, session management can be an alternative for certain scenarios. Implementing secure session management involves handling session tokens, expiration, and ensuring secure storage. Cross-Origin Resource Sharing (CORS) : CORS is configured on the backend to restrict cross-origin requests and prevent unauthorized access from different domains. Content Security Policy (CSP) : - CSP is used to specify the sources from which the application can load resources like scripts, stylesheets, and images. It helps prevent code injection attacks. Authentication and Authorization Middleware : - Custom middleware can be developed and applied to endpoints to enforce authentication and authorization rules across the application. Regular Security Audits : - Regular security audits and penetration testing should be conducted to identify and address potential vulnerabilities proactively. By implementing these security measures and authentication methods, the Compax web app can maintain a high level of security and protect user data from unauthorized access and malicious attacks. Remember that security is an ongoing process, and it's essential to stay up-to-date with security best practices and address new threats as they arise.","title":"Security"},{"location":"005_security_measures_and_authentication/#security","text":"Security is a critical aspect of any web application, and the Compax web app must implement robust measures to protect user data, prevent unauthorized access, and ensure secure communication between the frontend and backend. Here's an elaboration on the security measures and authentication methods used in the Compax web app: Secure Communication (HTTPS) : All communication between the frontend and backend of the Compax web app should be encrypted using HTTPS (HTTP Secure). HTTPS ensures that data transmitted between the client and server is encrypted, preventing eavesdropping and man-in-the-middle attacks. Authentication with JSON Web Tokens (JWT) : JSON Web Tokens (JWT) are used for user authentication in the Compax web app. When a user successfully logs in, the backend generates a JWT containing user information and a signature. This token is then sent back to the client and included in subsequent requests as an Authorization header. The server verifies the JWT's authenticity and extracts user information from it to grant access to protected endpoints. JWTs are stateless, meaning the server does not need to store session data, reducing server-side overhead. Hashing and Salting Passwords : User passwords should never be stored in plaintext. Instead, they are hashed and salted before being stored in the database. Hashing transforms the password into an irreversible string, while salting adds additional randomness to the hashing process, making it more secure against brute-force attacks. User Roles and Permissions : Different user roles (regular users, administrators, exam officers) have varying levels of access to the application's functionalities. Role-based access control (RBAC) is implemented to ensure that users can only access features relevant to their roles. Rate Limiting : Rate limiting is implemented to prevent brute-force attacks and excessive API requests from a single client. By imposing limits on the number of requests a client can make within a specific time frame, the backend mitigates potential abuse. Input Validation and Sanitization : Input validation is crucial to prevent security vulnerabilities like SQL injection and cross-site scripting (XSS). All user inputs should be validated and sanitized before processing to avoid malicious code execution. Error Handling and Logging : Comprehensive error handling is implemented to provide users with appropriate error messages while avoiding exposing sensitive information. Logs are generated to monitor application behavior and identify potential security issues. - Session Management (Optional) : While the Compax web app primarily uses stateless JWT authentication, session management can be an alternative for certain scenarios. Implementing secure session management involves handling session tokens, expiration, and ensuring secure storage. Cross-Origin Resource Sharing (CORS) : CORS is configured on the backend to restrict cross-origin requests and prevent unauthorized access from different domains. Content Security Policy (CSP) : - CSP is used to specify the sources from which the application can load resources like scripts, stylesheets, and images. It helps prevent code injection attacks. Authentication and Authorization Middleware : - Custom middleware can be developed and applied to endpoints to enforce authentication and authorization rules across the application. Regular Security Audits : - Regular security audits and penetration testing should be conducted to identify and address potential vulnerabilities proactively. By implementing these security measures and authentication methods, the Compax web app can maintain a high level of security and protect user data from unauthorized access and malicious attacks. Remember that security is an ongoing process, and it's essential to stay up-to-date with security best practices and address new threats as they arise.","title":"Security"},{"location":"007_development/","text":"Project Development Setting up a development environment for the backend of the Compax web app involves installing the necessary tools and dependencies to start building and testing the API using FastAPI and Python. Below is a step-by-step guide to setting up the development environment: Dependencies Ensure that Python is installed on your system. FastAPI requires Python 3.9 or higher. You can download the latest version of Python from the official Python website ( https://www.python.org/downloads/ ). Follow the installation instructions for your operating system. You would need a project dependency and packaging management to efficiently be able to manage all dependencies that's why Poetry is our preferred tool for managing this project. Install Dependencies : It's recommended to create a virtual environment for isolating the project's dependencies. This ensures that the dependencies for the Compax web app won't interfere with other projects. Navigate to the root directory of the project (where pyproject.toml is located) and install the required dependencies using Poetry. If you haven't installed Poetry, follow the installation instructions from the Poetry website ( https://python-poetry.org/docs/#installation ). Create a virtual environment with Poetry by invoking the following command: poetry shell This would create .venv directory or cached virtual environment depending on the configurations set for the tool. While your project environment has been successfully created, poetry will automatically try to activate the environment. If you do not see any such thing; proceed to activate the environment using the following commands. Windows : compax-env\\Scripts\\activate Mac / Linux : source compax-env/bin/activate Run the following command to install the project dependencies: poetry install This will install all the required packages specified in the pyproject.toml file. Run Server : After installing the dependencies, you can run the development server using uvicorn , the ASGI server implementation. uvicorn main:app --reload This will start the FastAPI development server, and the API will be accessible at http://127.0.0.1:8000 . Testing : With the development server running, you can now test the API using tools like curl , Postman, or any API testing tool of your choice. For an interactive API documentation, open your web browser and go to http://127.0.0.1:8000/api/bare/docs . This will display the automatically generated Swagger documentation, where you can explore the available endpoints and test them interactively. Connecting Databases Database Configuration : Ensure that you have PostgreSQL installed and running on your system or in a docker instance or on a remote database instance (because we used Supabase for all our PostgreSQL database interactions). To communicate with your database, a connection url or the database details are usually stored in an .env as show below and retrieved for any level of interaction. ENV_NAME='development' SUPABASE_CLIENT_URL='client_url_authentication' SUPABASE_CLIENT_KEY='client_anon_key_authentication' DB_URL='supabase_instance_dsn' DB_NAME='supabase' DB_USER='supabase' DB_PASSWORD='very_long_password' DB_HOST='supabase_instance_link' DB_PORT='normal_port' Update the database settings in the backend code to point to your PostgreSQL database. The information is then retrieved from the gitignored .env and passed along to anywhere it is needed in the code with a cache wrapper. from functools import lru_cache from pathlib import Path from pydantic import BaseSettings cwd = Path.cwd() base_env = cwd / \".env\" prod_env = cwd / \"prod.env\" class Settings(BaseSettings): env_name: str = \"\" supabase_client_url: str = \"\" supabase_client_key: str = \"\" db_url: str = \"\" db_name: str = \"\" db_user: str = \"\" db_port: int = 0 db_password: str = \"\" db_host: str = \"\" class Config: # allows the import of environment variables from .env # env file has variables included as attributes in # this class and more. you can decide to go with the # default preset used above or set your own .env file env_file = base_env env_file_encoding = \"utf-8\" @lru_cache def get_settings() -> Settings: settings = Settings() return settings Implement Endpoints and Features : With the development environment set up, you can now start implementing the various endpoints and features required for the Compax web app. Use the provided Python files ( admin.py , auth.py , building.py , etc.) as a starting point and customize them based on your project requirements. Version Control : Use a version control system like Git to track changes in your code. Initialize a Git repository in the project directory and commit your code regularly. By following these steps, you'll have a fully functional development environment set up for the backend of the Compax web app. You can now start building and testing the API, implementing the required endpoints, and working on other features of the web application.","title":"Project Development"},{"location":"007_development/#project-development","text":"Setting up a development environment for the backend of the Compax web app involves installing the necessary tools and dependencies to start building and testing the API using FastAPI and Python. Below is a step-by-step guide to setting up the development environment:","title":"Project Development"},{"location":"007_development/#dependencies","text":"Ensure that Python is installed on your system. FastAPI requires Python 3.9 or higher. You can download the latest version of Python from the official Python website ( https://www.python.org/downloads/ ). Follow the installation instructions for your operating system. You would need a project dependency and packaging management to efficiently be able to manage all dependencies that's why Poetry is our preferred tool for managing this project. Install Dependencies : It's recommended to create a virtual environment for isolating the project's dependencies. This ensures that the dependencies for the Compax web app won't interfere with other projects. Navigate to the root directory of the project (where pyproject.toml is located) and install the required dependencies using Poetry. If you haven't installed Poetry, follow the installation instructions from the Poetry website ( https://python-poetry.org/docs/#installation ). Create a virtual environment with Poetry by invoking the following command: poetry shell This would create .venv directory or cached virtual environment depending on the configurations set for the tool. While your project environment has been successfully created, poetry will automatically try to activate the environment. If you do not see any such thing; proceed to activate the environment using the following commands. Windows : compax-env\\Scripts\\activate Mac / Linux : source compax-env/bin/activate Run the following command to install the project dependencies: poetry install This will install all the required packages specified in the pyproject.toml file. Run Server : After installing the dependencies, you can run the development server using uvicorn , the ASGI server implementation. uvicorn main:app --reload This will start the FastAPI development server, and the API will be accessible at http://127.0.0.1:8000 . Testing : With the development server running, you can now test the API using tools like curl , Postman, or any API testing tool of your choice. For an interactive API documentation, open your web browser and go to http://127.0.0.1:8000/api/bare/docs . This will display the automatically generated Swagger documentation, where you can explore the available endpoints and test them interactively.","title":"Dependencies"},{"location":"007_development/#connecting-databases","text":"Database Configuration : Ensure that you have PostgreSQL installed and running on your system or in a docker instance or on a remote database instance (because we used Supabase for all our PostgreSQL database interactions). To communicate with your database, a connection url or the database details are usually stored in an .env as show below and retrieved for any level of interaction. ENV_NAME='development' SUPABASE_CLIENT_URL='client_url_authentication' SUPABASE_CLIENT_KEY='client_anon_key_authentication' DB_URL='supabase_instance_dsn' DB_NAME='supabase' DB_USER='supabase' DB_PASSWORD='very_long_password' DB_HOST='supabase_instance_link' DB_PORT='normal_port' Update the database settings in the backend code to point to your PostgreSQL database. The information is then retrieved from the gitignored .env and passed along to anywhere it is needed in the code with a cache wrapper. from functools import lru_cache from pathlib import Path from pydantic import BaseSettings cwd = Path.cwd() base_env = cwd / \".env\" prod_env = cwd / \"prod.env\" class Settings(BaseSettings): env_name: str = \"\" supabase_client_url: str = \"\" supabase_client_key: str = \"\" db_url: str = \"\" db_name: str = \"\" db_user: str = \"\" db_port: int = 0 db_password: str = \"\" db_host: str = \"\" class Config: # allows the import of environment variables from .env # env file has variables included as attributes in # this class and more. you can decide to go with the # default preset used above or set your own .env file env_file = base_env env_file_encoding = \"utf-8\" @lru_cache def get_settings() -> Settings: settings = Settings() return settings Implement Endpoints and Features : With the development environment set up, you can now start implementing the various endpoints and features required for the Compax web app. Use the provided Python files ( admin.py , auth.py , building.py , etc.) as a starting point and customize them based on your project requirements. Version Control : Use a version control system like Git to track changes in your code. Initialize a Git repository in the project directory and commit your code regularly. By following these steps, you'll have a fully functional development environment set up for the backend of the Compax web app. You can now start building and testing the API, implementing the required endpoints, and working on other features of the web application.","title":"Connecting Databases"},{"location":"008_database_design_and_schema/","text":"Database Design The database design and schema for the Compax web app are crucial components that define the structure and organization of data within the application. A well-designed database schema ensures efficient data storage, retrieval, and integrity. Below is an elaboration of the database design and schema for the Compax web app. Entity-Relationship Diagram (ERD) An Entity-Relationship Diagram (ERD) is a visual representation of the database schema, showing the entities (tables) and their relationships. The ERD for the Compax web app might include the following entities: Table Structure and Data Types The table structure for each entity in the database is defined by specifying the columns (attributes) and their corresponding data types. For example: Users This table stores information about the users of the system, including their username, student reference number, department, year group, password, and whether they are a class rep, admin, or exams officer. ```sql create table public.users ( id uuid not null, username text not null, student_reference bigint not null, department text not null default ''::text, year_group smallint null, password text not null, is_classrep boolean null, is_admin boolean null, created_at timestamp without time zone null default (now() at time zone 'utc'::text), is_deleted boolean null, is_exams_officer boolean null, constraint users_pkey primary key (id), constraint users_password_key unique (password), constraint users_student_reference_key unique (student_reference), constraint users_username_key unique (username), constraint users_id_fkey foreign key (id) references auth.users (id), constraint users_year_group_check check ( ( (year_group < 7) and (year_group > 0) ) ) ) tablespace pg_default; ``` Geometry Tables These tables store geometric data about the buildings, classrooms, and laboratories on campus. The buildings table stores information about the name, building type, number of floors, number of classrooms, and number of laboratories in each building. The classrooms table stores information about the name, room number, and floor number of each classroom. The laboratories table stores information about the lab reference, floor number, and building ID of each laboratory. Buildings ```sql create table public.buildings ( id bigint generated by default as identity, name text not null, building_type text null, n_floors bigint not null default '0'::bigint, n_classrooms bigint not null default '0'::bigint, n_labs bigint not null default '0'::bigint, geom geometry null, building_id bigint null, image_url text[] null, constraint buildings_pkey primary key (id), constraint buildings_geom_key unique (geom), constraint buildings_name_key unique (name), constraint buildings_building_id_fkey foreign key (building_id) references buildings (id) on delete cascade ) tablespace pg_default; ``` Classrooms ```sql create table public.classrooms ( id bigint generated by default as identity, name text null, room_number bigint null, floor_number bigint null, geom geometry null, building_id bigint null, image_url text[] null, constraint classrooms_pkey primary key (id), constraint classrooms_name_key unique (name), constraint classrooms_building_id_fkey foreign key (building_id) references buildings (id) on delete cascade ) tablespace pg_default; ``` Laboratories ```sql create table public.laboratories ( id bigint generated by default as identity, lab_reference text not null, floor_number bigint null default '0'::bigint, geom geometry null, building_id bigint null, image_url text[] null, constraint laboratories_pkey primary key (id), constraint laboratories_geom_key unique (geom), constraint laboratories_lab_reference_key unique (lab_reference), constraint laboratories_building_id_fkey foreign key (building_id) references buildings (id) on delete cascade ) tablespace pg_default; ``` Offices Evaluation Tables These tables store information about the ratings that users have given to different aspects of the university. The ratings table stores the rating, comment, and timestamp for each rating. Ratings ```sql create table public.ratings ( id bigint generated by default as identity, comments text not null default ''::text, building_id bigint null, classroom_id bigint null, office_id bigint null, lab_id bigint null, rate_value integer not null, constraint ratings_pkey primary key (id), constraint ratings_building_id_fkey foreign key (building_id) references buildings (id), constraint ratings_classroom_id_fkey foreign key (classroom_id) references classrooms (id), constraint ratings_lab_id_fkey foreign key (lab_id) references laboratories (id), constraint ratings_office_id_fkey foreign key (office_id) references offices (id), constraint ratings_rate_value_check check ( ( (rate_value < 6) and (rate_value > 0) ) ) ) tablespace pg_default; ``` Scheduling Tables These tables store information about the academic events that take place on campus. The academic_event_week table stores information about the weekday, department, schedule ID, and track ID for each academic event week. The academic_track table stores information about the semester, semester start date, semester end date, and academic year for each academic track. The session_schedule table stores information about the course code, course name, year group, schedule time, class location, and lab location for each session schedule. The session_time table stores information about the start time and end time for each session time. Academic Event Week ```sql create table public.academic_event_week ( id bigint generated by default as identity, weekday text null, department text null, schedule_id bigint null, track_id bigint null, constraint academic_event_week_pkey primary key (id), constraint academic_event_week_schedule_id_fkey foreign key (schedule_id) references session_schedule (id), constraint academic_event_week_track_id_fkey foreign key (track_id) references academic_track (id) ) tablespace pg_default; ``` Academic Track ```sql create table public.academic_track ( id bigint generated by default as identity, semester bigint null, semester_start date null, semester_end date null, academic_year text null, constraint academic_track_pkey primary key (id) ) tablespace pg_default; ``` Session Schedule ```sql create table public.session_schedule ( id bigint generated by default as identity, course_code text null, course_name text null, year_group bigint null, schedule_time bigint null, class_location bigint null, lab_location bigint null, constraint session_schedule_pkey primary key (id), constraint session_schedule_class_location_fkey foreign key (class_location) references classrooms (id), constraint session_schedule_lab_location_fkey foreign key (lab_location) references laboratories (id), constraint session_schedule_schedule_time_fkey foreign key (schedule_time) references session_time (id) on delete cascade ) tablespace pg_default; ``` Session Time ```sql create table public.session_time ( id bigint generated by default as identity, start_time time without time zone null, end_time time without time zone null, constraint session_time_pkey primary key (id) ) tablespace pg_default; ``` The choice of data types for each column ensures that the database efficiently stores and retrieves the data, while also enforcing data integrity constraints. Normalization and Data Integrity Database normalization is applied to ensure data integrity and to reduce data redundancy. The schema is organized into multiple tables, with each table focused on a specific entity. Relationships between entities are established using foreign keys, maintaining referential integrity. Indexes and Performance Optimization Proper indexing is essential for improving query performance. Indexes are created on columns that are frequently used for filtering or searching data, such as the user ID, building ID, classroom ID, etc. Additionally, unique constraints and primary keys help maintain data uniqueness and integrity. The database design and schema should be carefully planned and optimized to meet the specific requirements of the Compax web app. Regular backups and maintenance procedures should be implemented to ensure data reliability and security.","title":"Database Design"},{"location":"008_database_design_and_schema/#database-design","text":"The database design and schema for the Compax web app are crucial components that define the structure and organization of data within the application. A well-designed database schema ensures efficient data storage, retrieval, and integrity. Below is an elaboration of the database design and schema for the Compax web app.","title":"Database Design"},{"location":"008_database_design_and_schema/#entity-relationship-diagram-erd","text":"An Entity-Relationship Diagram (ERD) is a visual representation of the database schema, showing the entities (tables) and their relationships. The ERD for the Compax web app might include the following entities:","title":"Entity-Relationship Diagram (ERD)"},{"location":"008_database_design_and_schema/#table-structure-and-data-types","text":"The table structure for each entity in the database is defined by specifying the columns (attributes) and their corresponding data types. For example:","title":"Table Structure and Data Types"},{"location":"008_database_design_and_schema/#users","text":"This table stores information about the users of the system, including their username, student reference number, department, year group, password, and whether they are a class rep, admin, or exams officer. ```sql create table public.users ( id uuid not null, username text not null, student_reference bigint not null, department text not null default ''::text, year_group smallint null, password text not null, is_classrep boolean null, is_admin boolean null, created_at timestamp without time zone null default (now() at time zone 'utc'::text), is_deleted boolean null, is_exams_officer boolean null, constraint users_pkey primary key (id), constraint users_password_key unique (password), constraint users_student_reference_key unique (student_reference), constraint users_username_key unique (username), constraint users_id_fkey foreign key (id) references auth.users (id), constraint users_year_group_check check ( ( (year_group < 7) and (year_group > 0) ) ) ) tablespace pg_default; ```","title":"Users"},{"location":"008_database_design_and_schema/#geometry-tables","text":"These tables store geometric data about the buildings, classrooms, and laboratories on campus. The buildings table stores information about the name, building type, number of floors, number of classrooms, and number of laboratories in each building. The classrooms table stores information about the name, room number, and floor number of each classroom. The laboratories table stores information about the lab reference, floor number, and building ID of each laboratory. Buildings ```sql create table public.buildings ( id bigint generated by default as identity, name text not null, building_type text null, n_floors bigint not null default '0'::bigint, n_classrooms bigint not null default '0'::bigint, n_labs bigint not null default '0'::bigint, geom geometry null, building_id bigint null, image_url text[] null, constraint buildings_pkey primary key (id), constraint buildings_geom_key unique (geom), constraint buildings_name_key unique (name), constraint buildings_building_id_fkey foreign key (building_id) references buildings (id) on delete cascade ) tablespace pg_default; ``` Classrooms ```sql create table public.classrooms ( id bigint generated by default as identity, name text null, room_number bigint null, floor_number bigint null, geom geometry null, building_id bigint null, image_url text[] null, constraint classrooms_pkey primary key (id), constraint classrooms_name_key unique (name), constraint classrooms_building_id_fkey foreign key (building_id) references buildings (id) on delete cascade ) tablespace pg_default; ``` Laboratories ```sql create table public.laboratories ( id bigint generated by default as identity, lab_reference text not null, floor_number bigint null default '0'::bigint, geom geometry null, building_id bigint null, image_url text[] null, constraint laboratories_pkey primary key (id), constraint laboratories_geom_key unique (geom), constraint laboratories_lab_reference_key unique (lab_reference), constraint laboratories_building_id_fkey foreign key (building_id) references buildings (id) on delete cascade ) tablespace pg_default; ``` Offices","title":"Geometry Tables"},{"location":"008_database_design_and_schema/#evaluation-tables","text":"These tables store information about the ratings that users have given to different aspects of the university. The ratings table stores the rating, comment, and timestamp for each rating. Ratings ```sql create table public.ratings ( id bigint generated by default as identity, comments text not null default ''::text, building_id bigint null, classroom_id bigint null, office_id bigint null, lab_id bigint null, rate_value integer not null, constraint ratings_pkey primary key (id), constraint ratings_building_id_fkey foreign key (building_id) references buildings (id), constraint ratings_classroom_id_fkey foreign key (classroom_id) references classrooms (id), constraint ratings_lab_id_fkey foreign key (lab_id) references laboratories (id), constraint ratings_office_id_fkey foreign key (office_id) references offices (id), constraint ratings_rate_value_check check ( ( (rate_value < 6) and (rate_value > 0) ) ) ) tablespace pg_default; ```","title":"Evaluation Tables"},{"location":"008_database_design_and_schema/#scheduling-tables","text":"These tables store information about the academic events that take place on campus. The academic_event_week table stores information about the weekday, department, schedule ID, and track ID for each academic event week. The academic_track table stores information about the semester, semester start date, semester end date, and academic year for each academic track. The session_schedule table stores information about the course code, course name, year group, schedule time, class location, and lab location for each session schedule. The session_time table stores information about the start time and end time for each session time. Academic Event Week ```sql create table public.academic_event_week ( id bigint generated by default as identity, weekday text null, department text null, schedule_id bigint null, track_id bigint null, constraint academic_event_week_pkey primary key (id), constraint academic_event_week_schedule_id_fkey foreign key (schedule_id) references session_schedule (id), constraint academic_event_week_track_id_fkey foreign key (track_id) references academic_track (id) ) tablespace pg_default; ``` Academic Track ```sql create table public.academic_track ( id bigint generated by default as identity, semester bigint null, semester_start date null, semester_end date null, academic_year text null, constraint academic_track_pkey primary key (id) ) tablespace pg_default; ``` Session Schedule ```sql create table public.session_schedule ( id bigint generated by default as identity, course_code text null, course_name text null, year_group bigint null, schedule_time bigint null, class_location bigint null, lab_location bigint null, constraint session_schedule_pkey primary key (id), constraint session_schedule_class_location_fkey foreign key (class_location) references classrooms (id), constraint session_schedule_lab_location_fkey foreign key (lab_location) references laboratories (id), constraint session_schedule_schedule_time_fkey foreign key (schedule_time) references session_time (id) on delete cascade ) tablespace pg_default; ``` Session Time ```sql create table public.session_time ( id bigint generated by default as identity, start_time time without time zone null, end_time time without time zone null, constraint session_time_pkey primary key (id) ) tablespace pg_default; ``` The choice of data types for each column ensures that the database efficiently stores and retrieves the data, while also enforcing data integrity constraints.","title":"Scheduling Tables"},{"location":"008_database_design_and_schema/#normalization-and-data-integrity","text":"Database normalization is applied to ensure data integrity and to reduce data redundancy. The schema is organized into multiple tables, with each table focused on a specific entity. Relationships between entities are established using foreign keys, maintaining referential integrity.","title":"Normalization and Data Integrity"},{"location":"008_database_design_and_schema/#indexes-and-performance-optimization","text":"Proper indexing is essential for improving query performance. Indexes are created on columns that are frequently used for filtering or searching data, such as the user ID, building ID, classroom ID, etc. Additionally, unique constraints and primary keys help maintain data uniqueness and integrity. The database design and schema should be carefully planned and optimized to meet the specific requirements of the Compax web app. Regular backups and maintenance procedures should be implemented to ensure data reliability and security.","title":"Indexes and Performance Optimization"},{"location":"009_endpoints/","text":"API default GET / Root GET /search/classrooms : Query Classrooms By Parameters GET /search/buildings : Query Buildings By Parameters GET /search/labs : Query Labs By Parameters GET /search/offices : Query Offices By Parameters users GET /i/{reference} : Get User By Reference GET /i/{uuid} : Get User By Uuid GET /i/{username} : Get User By Username POST /i/new : Create User POST /i/admin/new : Create Admin POST /i/officer/new : Create Officer auth GET /auth/signin : Sign In POST /auth/signout : Sign Out POST /auth/signup : Sign Up POST /auth/admin/signup : Sign Up Admin POST /auth/officer/signup : Sign Up Examofficer classrooms GET /classrooms/ : Get All Classrooms GET /classroom/{classroom_id} : Get Classroom PUT /classrooms/{classroom_id} : Update Classroom DELETE /classrooms/{classroom_id} : Delete Classroom POST /classrooms/new : Create Classroom buildings GET /buildings/ : Get All Buildings GET /buildings/{building_id} : Get Building PUT /buildings/{building_id} : Update Building DELETE /buildings/{building_id} : Delete Building POST /buildings/new : Create Building labs GET /labs : Get All Labs GET /labs/{lab_id} : Get Lab PUT /labs/{lab_id} : Update Lab DELETE /labs/{lab_id} : Delete Lab POST /labs/new : Create Lab offices GET /offices : Get All Offices GET /offices/{office_id} : Get Office PUT /offices/{office_id} : Update Office DELETE /offices/{office_id} : Delete Office POST /offices/new : Create Office","title":"API"},{"location":"009_endpoints/#api","text":"default GET / Root GET /search/classrooms : Query Classrooms By Parameters GET /search/buildings : Query Buildings By Parameters GET /search/labs : Query Labs By Parameters GET /search/offices : Query Offices By Parameters users GET /i/{reference} : Get User By Reference GET /i/{uuid} : Get User By Uuid GET /i/{username} : Get User By Username POST /i/new : Create User POST /i/admin/new : Create Admin POST /i/officer/new : Create Officer auth GET /auth/signin : Sign In POST /auth/signout : Sign Out POST /auth/signup : Sign Up POST /auth/admin/signup : Sign Up Admin POST /auth/officer/signup : Sign Up Examofficer classrooms GET /classrooms/ : Get All Classrooms GET /classroom/{classroom_id} : Get Classroom PUT /classrooms/{classroom_id} : Update Classroom DELETE /classrooms/{classroom_id} : Delete Classroom POST /classrooms/new : Create Classroom buildings GET /buildings/ : Get All Buildings GET /buildings/{building_id} : Get Building PUT /buildings/{building_id} : Update Building DELETE /buildings/{building_id} : Delete Building POST /buildings/new : Create Building labs GET /labs : Get All Labs GET /labs/{lab_id} : Get Lab PUT /labs/{lab_id} : Update Lab DELETE /labs/{lab_id} : Delete Lab POST /labs/new : Create Lab offices GET /offices : Get All Offices GET /offices/{office_id} : Get Office PUT /offices/{office_id} : Update Office DELETE /offices/{office_id} : Delete Office POST /offices/new : Create Office","title":"API"},{"location":"010_error_handling_and_logging/","text":"Error Handling Error handling and logging are critical aspects of the backend development process, ensuring that the Compax web app can identify, handle, and log errors effectively. Proper error handling provides meaningful feedback to users and helps developers identify and fix issues quickly. Here's an elaboration on error handling and logging for the backend of the Compax web app: Custom Error Classes class CompaxException(HTTPException): def __init__(self, status_code: int, detail: str): super().__init__(status_code, detail=detail) class BuildingNotFoundException(CompaxException): def __init__(self, building_id: str): detail = f\"Building with ID {building_id} not found.\" super().__init__(status_code=404, detail=detail) class ClassroomNotFoundException(CompaxException): def __init__(self, classroom_id: str): detail = f\"Classroom with ID {classroom_id} not found.\" super().__init__(status_code=404, detail=detail) class LaboratoryNotFoundException(CompaxException): def __init__(self, laboratory_id: str): detail = f\"Laboratory with ID {laboratory_id} not found.\" super().__init__(status_code=404, detail=detail) class OfficeNotFoundException(CompaxException): def __init__(self, office_id: str): detail = f\"Office with ID {office_id} not found.\" super().__init__(status_code=404, detail=detail) class UserNotFoundException(CompaxException): def __init__(self, message: str): detail = f\"{message}\" super().__init__(status_code=404, detail=detail) class UserReferenceFoundException(CompaxException): def __init__(self, ref: int): detail = f\"User with Reference {int} not found.\" super().__init__(status_code=404, detail=detail) class UserNameNotFoundException(CompaxException): def __init__(self, username: str): detail = f\"User with name {username} not found.\" super().__init__(status_code=404, detail=detail) class AuthInvalidCredentialsException(CompaxException): def __init__(self): super().__init__( status_code=401, detail=\"Invalid credentials. \" + \"User might exist. User with reference might exist. \" + \"User year group might be Incorrect\", ) class InvalidRatingException(CompaxException): def __init__(self): super().__init__( status_code=401, detail=\"Invalid credentials. Details Provided might incorrect!\", ) class UnauthorizedException(CompaxException): def __init__(self): super().__init__(status_code=403, detail=\"Unauthorized access.\") class BookingNotFoundException(CompaxException): def __init__(self, booking_id: str): detail = f\"Booking with ID {booking_id} not found.\" super().__init__(status_code=404, detail=detail)","title":"Error Handling"},{"location":"010_error_handling_and_logging/#error-handling","text":"Error handling and logging are critical aspects of the backend development process, ensuring that the Compax web app can identify, handle, and log errors effectively. Proper error handling provides meaningful feedback to users and helps developers identify and fix issues quickly. Here's an elaboration on error handling and logging for the backend of the Compax web app:","title":"Error Handling"},{"location":"010_error_handling_and_logging/#custom-error-classes","text":"class CompaxException(HTTPException): def __init__(self, status_code: int, detail: str): super().__init__(status_code, detail=detail) class BuildingNotFoundException(CompaxException): def __init__(self, building_id: str): detail = f\"Building with ID {building_id} not found.\" super().__init__(status_code=404, detail=detail) class ClassroomNotFoundException(CompaxException): def __init__(self, classroom_id: str): detail = f\"Classroom with ID {classroom_id} not found.\" super().__init__(status_code=404, detail=detail) class LaboratoryNotFoundException(CompaxException): def __init__(self, laboratory_id: str): detail = f\"Laboratory with ID {laboratory_id} not found.\" super().__init__(status_code=404, detail=detail) class OfficeNotFoundException(CompaxException): def __init__(self, office_id: str): detail = f\"Office with ID {office_id} not found.\" super().__init__(status_code=404, detail=detail) class UserNotFoundException(CompaxException): def __init__(self, message: str): detail = f\"{message}\" super().__init__(status_code=404, detail=detail) class UserReferenceFoundException(CompaxException): def __init__(self, ref: int): detail = f\"User with Reference {int} not found.\" super().__init__(status_code=404, detail=detail) class UserNameNotFoundException(CompaxException): def __init__(self, username: str): detail = f\"User with name {username} not found.\" super().__init__(status_code=404, detail=detail) class AuthInvalidCredentialsException(CompaxException): def __init__(self): super().__init__( status_code=401, detail=\"Invalid credentials. \" + \"User might exist. User with reference might exist. \" + \"User year group might be Incorrect\", ) class InvalidRatingException(CompaxException): def __init__(self): super().__init__( status_code=401, detail=\"Invalid credentials. Details Provided might incorrect!\", ) class UnauthorizedException(CompaxException): def __init__(self): super().__init__(status_code=403, detail=\"Unauthorized access.\") class BookingNotFoundException(CompaxException): def __init__(self, booking_id: str): detail = f\"Booking with ID {booking_id} not found.\" super().__init__(status_code=404, detail=detail)","title":"Custom Error Classes"},{"location":"011_testing_approaches_and_test_cases/","text":"Testing Testing is a critical aspect of software development to ensure the reliability and functionality of the backend of the Compax web app. Here are some testing approaches and test cases that can be used to validate the backend's behavior: - Unit Testing - Test Cases: - Test individual functions and methods of the backend components in isolation. - Verify that each function returns the expected output for different inputs. - Check error handling for edge cases and invalid inputs. Purpose Unit testing focuses on testing small units of code to identify and fix bugs at an early stage. It ensures that each function or method behaves as intended and that changes in one unit do not break other parts of the code. - Integration Testing Test Cases Test the integration between different backend components, modules, and APIs. Validate the flow of data and interactions between components. Check if data is correctly passed between different layers of the backend, such as the application layer, business logic, and data access layer. Purpose Integration testing ensures that the interactions between various components are working correctly, preventing integration-related issues in the final application. - API Testing Test Cases Test each endpoint of the API with various inputs and scenarios. Verify that the API responses contain the expected data and are in the correct format (e.g., JSON). Check the handling of different HTTP methods (GET, POST, PUT, DELETE). Purpose API testing ensures that the backend API is functioning correctly and providing accurate responses to client requests. - Database Testing Database / Test Cases Test CRUD (Create, Read, Update, Delete) operations on the database. Verify that data is correctly stored and retrieved from the database. Check the handling of data constraints, such as unique keys and foreign key relationships. Database / Purpose Database testing ensures data integrity and that the backend can interact with the database without errors. - Error Handling Testing Errors / Test Cases Test error scenarios and check how the backend handles unexpected situations, such as invalid input or database connection failures. Verify that appropriate error codes and messages are returned in the API responses. Errors / Purpose Error handling testing ensures that the backend gracefully handles errors and provides meaningful feedback to users or client applications. - Performance Testing Perf / Test Cases Test the backend's performance under different load conditions and with large datasets. Measure response times and server resource utilization. Identify potential bottlenecks and areas for performance optimization. Perf / Purpose Performance testing ensures that the backend can handle the expected user load without degradation in response times. - Security Testing Security / Test Cases Test for common security vulnerabilities, such as SQL injection, cross-site scripting (XSS), and cross-site request forgery (CSRF). Verify that authentication and authorization mechanisms are properly implemented and protect sensitive data. Security / Purpose Security testing ensures that the backend is secure and protects user data from unauthorized access. Each of these testing approaches plays a vital role in ensuring the quality and reliability of the Compax backend. By thoroughly testing the application, developers can identify and fix issues early in the development process, leading to a more robust and stable backend for the Compax web app.","title":"Testing"},{"location":"011_testing_approaches_and_test_cases/#testing","text":"Testing is a critical aspect of software development to ensure the reliability and functionality of the backend of the Compax web app. Here are some testing approaches and test cases that can be used to validate the backend's behavior:","title":"Testing"},{"location":"011_testing_approaches_and_test_cases/#-unit-testing","text":"- Test Cases: - Test individual functions and methods of the backend components in isolation. - Verify that each function returns the expected output for different inputs. - Check error handling for edge cases and invalid inputs.","title":"- Unit Testing"},{"location":"011_testing_approaches_and_test_cases/#purpose","text":"Unit testing focuses on testing small units of code to identify and fix bugs at an early stage. It ensures that each function or method behaves as intended and that changes in one unit do not break other parts of the code.","title":"Purpose"},{"location":"011_testing_approaches_and_test_cases/#-integration-testing","text":"","title":"- Integration Testing"},{"location":"011_testing_approaches_and_test_cases/#test-cases","text":"Test the integration between different backend components, modules, and APIs. Validate the flow of data and interactions between components. Check if data is correctly passed between different layers of the backend, such as the application layer, business logic, and data access layer.","title":"Test Cases"},{"location":"011_testing_approaches_and_test_cases/#purpose_1","text":"Integration testing ensures that the interactions between various components are working correctly, preventing integration-related issues in the final application.","title":"Purpose"},{"location":"011_testing_approaches_and_test_cases/#-api-testing","text":"","title":"- API Testing"},{"location":"011_testing_approaches_and_test_cases/#test-cases_1","text":"Test each endpoint of the API with various inputs and scenarios. Verify that the API responses contain the expected data and are in the correct format (e.g., JSON). Check the handling of different HTTP methods (GET, POST, PUT, DELETE).","title":"Test Cases"},{"location":"011_testing_approaches_and_test_cases/#purpose_2","text":"API testing ensures that the backend API is functioning correctly and providing accurate responses to client requests.","title":"Purpose"},{"location":"011_testing_approaches_and_test_cases/#-database-testing","text":"","title":"- Database Testing"},{"location":"011_testing_approaches_and_test_cases/#database-test-cases","text":"Test CRUD (Create, Read, Update, Delete) operations on the database. Verify that data is correctly stored and retrieved from the database. Check the handling of data constraints, such as unique keys and foreign key relationships.","title":"Database / Test Cases"},{"location":"011_testing_approaches_and_test_cases/#database-purpose","text":"Database testing ensures data integrity and that the backend can interact with the database without errors.","title":"Database / Purpose"},{"location":"011_testing_approaches_and_test_cases/#-error-handling-testing","text":"","title":"- Error Handling Testing"},{"location":"011_testing_approaches_and_test_cases/#errors-test-cases","text":"Test error scenarios and check how the backend handles unexpected situations, such as invalid input or database connection failures. Verify that appropriate error codes and messages are returned in the API responses.","title":"Errors / Test Cases"},{"location":"011_testing_approaches_and_test_cases/#errors-purpose","text":"Error handling testing ensures that the backend gracefully handles errors and provides meaningful feedback to users or client applications.","title":"Errors / Purpose"},{"location":"011_testing_approaches_and_test_cases/#-performance-testing","text":"","title":"- Performance Testing"},{"location":"011_testing_approaches_and_test_cases/#perf-test-cases","text":"Test the backend's performance under different load conditions and with large datasets. Measure response times and server resource utilization. Identify potential bottlenecks and areas for performance optimization.","title":"Perf / Test Cases"},{"location":"011_testing_approaches_and_test_cases/#perf-purpose","text":"Performance testing ensures that the backend can handle the expected user load without degradation in response times.","title":"Perf / Purpose"},{"location":"011_testing_approaches_and_test_cases/#-security-testing","text":"","title":"- Security Testing"},{"location":"011_testing_approaches_and_test_cases/#security-test-cases","text":"Test for common security vulnerabilities, such as SQL injection, cross-site scripting (XSS), and cross-site request forgery (CSRF). Verify that authentication and authorization mechanisms are properly implemented and protect sensitive data.","title":"Security / Test Cases"},{"location":"011_testing_approaches_and_test_cases/#security-purpose","text":"Security testing ensures that the backend is secure and protects user data from unauthorized access. Each of these testing approaches plays a vital role in ensuring the quality and reliability of the Compax backend. By thoroughly testing the application, developers can identify and fix issues early in the development process, leading to a more robust and stable backend for the Compax web app.","title":"Security / Purpose"},{"location":"012_deployment_instructions/","text":"Deployment Deploying the backend of the Compax web app involves making it accessible on a production server to handle incoming requests from the frontend and clients. Below are step-by-step deployment instructions for the backend: Choose a Production Server Select a production server or cloud platform where the backend will be hosted. Common choices include AWS, Google Cloud Platform, Microsoft Azure, DigitalOcean, or Heroku. Consider factors such as scalability, performance, and pricing when making your decision. Prepare the Backend Code Ensure that the backend code is ready for deployment. This involves having the latest version of the code with all necessary configurations and dependencies. Environment Variables and Configuration Remove any development-specific configurations and ensure that all environment variables are properly set for the production environment. Use environment variables to store sensitive information, such as database credentials and API keys. Database Setup If using a database server, ensure that it is properly configured and accessible from the production environment. Set up the necessary database schema and user permissions. Dependency Management Make sure you have a proper dependency management system in place. In Python, you can use poetry or pip to manage dependencies. It's a good practice to use a virtual environment to isolate the dependencies. Web Server and ASGI Setup Deploy the backend using a production-ready ASGI server like Uvicorn or Hypercorn. These servers are designed to handle high-concurrency asynchronous requests. Ensure that the ASGI server is properly configured to run your FastAPI application. Security Configuration Enable HTTPS on the production server to ensure secure communication between the client and backend. Obtain and install an SSL/TLS certificate. Implement any additional security measures, such as setting up a Web Application Firewall (WAF) to protect against common web vulnerabilities. Performance Tuning and Caching Optimize your backend for performance by setting up caching mechanisms for frequently accessed data. Consider using Redis or Memcached for caching purposes. Logging and Monitoring Set up logging and monitoring tools to track application performance and identify potential issues. Tools like Prometheus and Grafana can be helpful for this purpose. Continuous Integration/Continuous Deployment (CI/CD) Implement a CI/CD pipeline to automate the deployment process. This ensures that changes are automatically tested, built, and deployed to the production server. Dockerize the Backend (Optional) If desired, create a Docker image of the backend application. Dockerizing the application provides a standardized deployment environment and simplifies the deployment process. Load Balancing and Scaling (Optional) If you expect high traffic, set up load balancing to distribute incoming requests across multiple backend instances. Consider using auto-scaling to dynamically adjust the number of instances based on demand. Deploy the Backend Upload your backend code and configurations to the production server or cloud platform. Start the ASGI server with your FastAPI application. Monitor the logs and ensure that the application is running as expected. Test and Monitor Perform thorough testing on the production environment to verify that the backend works as expected. Monitor the application continuously for performance, security, and stability. Rollback Plan Have a rollback plan in case any issues arise during or after deployment. This ensures that you can quickly revert to the previous stable version if needed. Remember to document the deployment process and keep your production environment up to date with the latest security patches and software updates. Regularly review and optimize your deployment setup to maintain a reliable and efficient backend for the Compax web app.","title":"Deployment"},{"location":"012_deployment_instructions/#deployment","text":"Deploying the backend of the Compax web app involves making it accessible on a production server to handle incoming requests from the frontend and clients. Below are step-by-step deployment instructions for the backend:","title":"Deployment"},{"location":"012_deployment_instructions/#choose-a-production-server","text":"Select a production server or cloud platform where the backend will be hosted. Common choices include AWS, Google Cloud Platform, Microsoft Azure, DigitalOcean, or Heroku. Consider factors such as scalability, performance, and pricing when making your decision.","title":"Choose a Production Server"},{"location":"012_deployment_instructions/#prepare-the-backend-code","text":"Ensure that the backend code is ready for deployment. This involves having the latest version of the code with all necessary configurations and dependencies.","title":"Prepare the Backend Code"},{"location":"012_deployment_instructions/#environment-variables-and-configuration","text":"Remove any development-specific configurations and ensure that all environment variables are properly set for the production environment. Use environment variables to store sensitive information, such as database credentials and API keys.","title":"Environment Variables and Configuration"},{"location":"012_deployment_instructions/#database-setup","text":"If using a database server, ensure that it is properly configured and accessible from the production environment. Set up the necessary database schema and user permissions.","title":"Database Setup"},{"location":"012_deployment_instructions/#dependency-management","text":"Make sure you have a proper dependency management system in place. In Python, you can use poetry or pip to manage dependencies. It's a good practice to use a virtual environment to isolate the dependencies.","title":"Dependency Management"},{"location":"012_deployment_instructions/#web-server-and-asgi-setup","text":"Deploy the backend using a production-ready ASGI server like Uvicorn or Hypercorn. These servers are designed to handle high-concurrency asynchronous requests. Ensure that the ASGI server is properly configured to run your FastAPI application.","title":"Web Server and ASGI Setup"},{"location":"012_deployment_instructions/#security-configuration","text":"Enable HTTPS on the production server to ensure secure communication between the client and backend. Obtain and install an SSL/TLS certificate. Implement any additional security measures, such as setting up a Web Application Firewall (WAF) to protect against common web vulnerabilities.","title":"Security Configuration"},{"location":"012_deployment_instructions/#performance-tuning-and-caching","text":"Optimize your backend for performance by setting up caching mechanisms for frequently accessed data. Consider using Redis or Memcached for caching purposes.","title":"Performance Tuning and Caching"},{"location":"012_deployment_instructions/#logging-and-monitoring","text":"Set up logging and monitoring tools to track application performance and identify potential issues. Tools like Prometheus and Grafana can be helpful for this purpose.","title":"Logging and Monitoring"},{"location":"012_deployment_instructions/#continuous-integrationcontinuous-deployment-cicd","text":"Implement a CI/CD pipeline to automate the deployment process. This ensures that changes are automatically tested, built, and deployed to the production server.","title":"Continuous Integration/Continuous Deployment (CI/CD)"},{"location":"012_deployment_instructions/#dockerize-the-backend-optional","text":"If desired, create a Docker image of the backend application. Dockerizing the application provides a standardized deployment environment and simplifies the deployment process.","title":"Dockerize the Backend (Optional)"},{"location":"012_deployment_instructions/#load-balancing-and-scaling-optional","text":"If you expect high traffic, set up load balancing to distribute incoming requests across multiple backend instances. Consider using auto-scaling to dynamically adjust the number of instances based on demand.","title":"Load Balancing and Scaling (Optional)"},{"location":"012_deployment_instructions/#deploy-the-backend","text":"Upload your backend code and configurations to the production server or cloud platform. Start the ASGI server with your FastAPI application. Monitor the logs and ensure that the application is running as expected.","title":"Deploy the Backend"},{"location":"012_deployment_instructions/#test-and-monitor","text":"Perform thorough testing on the production environment to verify that the backend works as expected. Monitor the application continuously for performance, security, and stability.","title":"Test and Monitor"},{"location":"012_deployment_instructions/#rollback-plan","text":"Have a rollback plan in case any issues arise during or after deployment. This ensures that you can quickly revert to the previous stable version if needed. Remember to document the deployment process and keep your production environment up to date with the latest security patches and software updates. Regularly review and optimize your deployment setup to maintain a reliable and efficient backend for the Compax web app.","title":"Rollback Plan"}]}; var __search = { index: Promise.resolve(local_index) }